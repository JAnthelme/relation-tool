-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Initial project template from stack
--   
--   A simple and lightweight relational algebra operators library (see
--   README.md).
@package relation-tool
@version 0.1.0.0


-- | Implementation of convenience operators on "labelled sets",
--   <a>LSet</a>s, which are a type synonym for <tt><a>Set</a>
--   (<a>String</a>, a)</tt>, that is a set of (label, value) pairs.
--   Unicity of labels is required and blank labels are prohibited.
--   
--   Relations are defined by their <a>Attributes</a> and the <a>Set</a> of
--   their <a>Rows</a> which are both defined as <a>LSet</a>s :
--   
--   <pre>
--   type Attributes = LSet <a>TypeRep</a>
--   </pre>
--   
--   <pre>
--   type Row = LSet <a>Elem</a>
--   </pre>
module Relvar.LSet

-- | Generic <a>Set</a> of (label, value) elements.
type LSet a = Set (String, a)

-- | Labels operators typeclass. Any <a>LSet</a> and <a>Relvar</a> are part
--   of this class.
--   
--   For <a>Relvar</a>s, the operators apply to the <a>Relvar'</a>s
--   <a>Attributes</a> (defined as <tt><a>LSet</a> <a>TypeRep</a></tt>).
class LabelOp a

-- | Check that two <a>LSet</a>s or two <a>Relvar</a>s are "compatible",
--   e.g. there is no label equality without value equality. For
--   <a>Relvar</a>s, <tt>True</tt> if their <a>Attributes</a> are
--   compatible.
compatible :: (LabelOp a, Ord a, Show a) => a -> a -> Bool

-- | <a>LSet</a>s equality. For <a>Relvar</a>s, <tt>True</tt> if the
--   <a>Attributes</a> of two relations are equal.
match :: (LabelOp a, Eq a) => a -> a -> Bool

-- | <tt>True</tt> if <a>LSet</a>s are <a>compatible</a> and
--   <a>disjoint</a>.
disjoint :: (LabelOp a, Ord a) => a -> a -> Bool

-- | Replace <tt>LSet's</tt> labels. For <a>Relvar</a>s, rename its
--   <a>Attributes'</a>s labels.
rename :: LabelOp a => a -> [String] -> [String] -> a

-- | Return <tt>LSet'</tt>s labels. For <a>Relvar</a>s, return its
--   <a>Attributes'</a>s labels.
labels :: LabelOp a => a -> [String]

-- | Return the number of elements in the set. For <a>Relvar</a>s, return
--   its <a>Attributes'</a>s size (e.g. its number of columns).
degree :: LabelOp a => a -> Int

-- | Empty set
empty :: LSet a

-- | Singleton set from a label and its corresponding element.
singleton :: String -> a -> LSet a

-- | Insert a label and corresponding value in an LSet. -- CHECK : 1) that
--   the label does not exist already 2) that the label is not blank
insert :: Ord a => String -> a -> LSet a -> LSet a

-- | Delete an element in an LSet.
delete :: String -> LSet a -> LSet a

-- | Return a LSet of the input LSet elements which labels are included in
--   the provided list.
project :: LSet a -> [String] -> LSet a

-- | Return a LSet of the input LSet elements which labels are not included
--   in the provided list.
projectaway :: (Ord a, Show a) => LSet a -> [String] -> LSet a

-- | Return common labels between the two LSets.
common :: Ord a => LSet a -> LSet a -> LSet a

-- | Union of the two LSets.
union :: Ord a => LSet a -> LSet a -> LSet a

-- | extract values provided labels. Preserve input labels order.
extract :: (Ord a, Show a) => Bool -> LSet a -> [String] -> [a]

-- | extract (label, value) provided labels. Preserve input labels order.
extractWithLabels :: (Ord a, Show a) => Bool -> [String] -> LSet a -> [(String, a)]
extract2 :: Ord a => [String] -> [(String, a)] -> [(String, a)]

-- | Return values of a given LSet. Note that the order of the list is
--   determined by the internal <a>Set</a> representation of the LSet
--   input.
values :: LSet a -> [a]

-- | Convert the set to a list of (label,value) pairs.
toList :: LSet a -> [(String, a)]

-- | Create a LSet from a list of labels and a corresponding list of
--   values.
fromList :: Ord a => [String] -> [a] -> LSet a

-- | Return <tt>True</tt> if no blank labels and, if chckDup flag is
--   <tt>True</tt>, no duplicate labels are found.
checkLabels :: Bool -> [String] -> Bool

-- | Return <tt>True</tt> if all labels are included in the provided LSet
--   and if <a>checkLabels</a> is also <tt>True</tt>.
--   
--   Similar to <a>compatible</a> but tests the compatibility of LSet's
--   labels vs the provided list of labels.
compatibleLabels :: (Ord a, Show a) => Bool -> LSet a -> [String] -> Bool
instance (GHC.Classes.Ord a, GHC.Show.Show a) => Relvar.LSet.LabelOp (Relvar.LSet.LSet a)
instance Relvar.LSet.LabelOp [GHC.Base.String]


-- | A simple representation of relation types based on C.J. Date, "<i>An
--   Introduction to Database Systems</i>" Eighth Edition.
--   
--   The representation of <a>Relvar</a> is based on <a>Set</a>s, where
--   each relation tuple is of the type <a>Row</a>, or a synonym for
--   <tt><a>Set</a> (<a>String</a>, <a>Elem</a>)</tt>. <a>Elem</a> is an
--   Algebraic Data Type representing each tuple's element.
module Relvar

-- | A concrete representation of a (monomorphic) type. <a>TypeRep</a>
--   supports reasonably efficient equality.
data TypeRep :: *

-- | Type for <tt>Relvar's</tt> elements. Elem types are either primitive
--   types or Relvars or array of Elems or tuple of Elems (2 and 3
--   arguments). One can extend the primitive types by adding to the code's
--   definitions (look for <tt>"-- ADD NEW TYPES HERE"</tt> comments in
--   code).
data Elem
Nil :: Elem
B :: Bool -> Elem
C :: Char -> Elem
S :: String -> Elem
T :: Text -> Elem
I :: Int -> Elem
J :: Integer -> Elem
D :: Double -> Elem
DD :: Day -> Elem
DT :: UTCTime -> Elem
BS :: ByteString -> Elem

-- | array of Elems
A :: [Elem] -> Elem

-- | pair of Elems
T2 :: (Elem, Elem) -> Elem

-- | triplet of Elems
T3 :: (Elem, Elem, Elem) -> Elem

-- | relation
R :: Relvar -> Elem

-- | convenient for ordering Elems in descending order
DW :: (Down Elem) -> Elem

-- | Attributes is the type synonym for <tt><a>LSet</a>
--   <a>TypeRep</a></tt>, i.e. for <tt><tt>Set</tt> (String, TypeRep)</tt>.
--   The LSet type enforces that there are no blank label, nor any
--   duplicate labels.
type Attributes = LSet TypeRep

-- | Row is synonym for <tt><a>LSet</a> <a>Elem</a></tt>, i.e. for
--   <tt><tt>Set</tt> (String, Elem)</tt>. The LSet type enforces that
--   there are no blank label, nor any duplicate label.
type Row = LSet Elem

-- | Relvar is the type for relations. A relation is defined by the set of
--   its attributes (i.e. labels' names and types) and of its tuples, or
--   rows, (i.e. sets of Elems). There is unicity of Attributes labels and
--   no two rows can be identical.
--   
--   See C.J. Date, "<i>An Introduction to Database Systems</i>" Eighth
--   Edition, chapter 6 ('Relations').
data Relvar
Relvar :: Attributes -> Set Row -> Relvar

-- | Set of the relation's attributes.
[attributes] :: Relvar -> Attributes

-- | Set of the relation's tuples (i.e. rows).
[rdata] :: Relvar -> Set Row

-- | Type for tables. A relation's table output is mostly for
--   representation. Unlike relations, tables can have duplicate rows and
--   column headers. See full difference between relations and tables in
--   C.J. Date, "<i>An Introduction to Database Systems</i>" Eighth
--   Edition, chapter 6 ('Relations').
data Table
Table :: [String] -> [[Elem]] -> Table
[header] :: Table -> [String]
[tdata] :: Table -> [[Elem]]

-- | ADT for selecting sorting in ascending or descending orders.
data ColOrder
Asc :: ColOrder
Desc :: ColOrder

-- | Class of any type <tt>a</tt> which can be reprensented as an Elem.
class Elementable a

-- | Conversion from types to their corresponding Elem ADT type.
toElem :: Elementable a => a -> Elem
fromElem :: Elementable a => Elem -> Maybe a

-- | Create a relation variable provided its <a>Attributes'</a> labels and
--   types (i.e. column names and types) and its <a>Row</a> elements.
relvar :: [String] -> [TypeRep] -> [[Elem]] -> Relvar

-- | Constant relation with an empty set of attributes and 1-tuple (equal
--   to the empty set) body ([C.J. Date] chap. 6).
--   
--   <tt>dee = Relvar {attributes= Set.empty, rdata = Set.singleton $
--   Set.empty}</tt>.
dee :: Relvar

-- | Constant relation with an empty set of attributes and no-tuple body
--   ([C.J. Date] chap. 6).
--   
--   <tt>dum = Relvar {attributes= Set.empty, rdata = Set.empty}</tt>.
dum :: Relvar

-- | Replace <tt>LSet's</tt> labels. For <a>Relvar</a>s, rename its
--   <a>Attributes'</a>s labels.
rename :: LabelOp a => a -> [String] -> [String] -> a

-- | Return the number of elements in the set. For <a>Relvar</a>s, return
--   its <a>Attributes'</a>s size (e.g. its number of columns).
degree :: LabelOp a => a -> Int

-- | Cardinality of a relation (i.e. # of tuples or # of rows).
card :: Relvar -> Int

-- | Extract all elements.
elems :: Relvar -> [[(String, Elem)]]

-- | Extract elements given labels.
elems' :: Relvar -> Bool -> [String] -> [[Elem]]

-- | Return <tt>LSet'</tt>s labels. For <a>Relvar</a>s, return its
--   <a>Attributes'</a>s labels.
labels :: LabelOp a => a -> [String]

-- | Return the all Attributes' types.
types :: Relvar -> [TypeRep]

-- | Return Attributes' types for the matching labels.
types' :: Relvar -> Bool -> [String] -> [TypeRep]

-- | Common attributes
common :: Relvar -> Relvar -> Attributes

-- | Check that two <a>LSet</a>s or two <a>Relvar</a>s are "compatible",
--   e.g. there is no label equality without value equality. For
--   <a>Relvar</a>s, <tt>True</tt> if their <a>Attributes</a> are
--   compatible.
compatible :: (LabelOp a, Ord a, Show a) => a -> a -> Bool

-- | <a>LSet</a>s equality. For <a>Relvar</a>s, <tt>True</tt> if the
--   <a>Attributes</a> of two relations are equal.
match :: (LabelOp a, Eq a) => a -> a -> Bool

-- | <tt>True</tt> if <a>LSet</a>s are <a>compatible</a> and
--   <a>disjoint</a>.
disjoint :: (LabelOp a, Ord a) => a -> a -> Bool

-- | Output a table given a set of labels, a row indexing function and a
--   list of row indices.
--   
--   If lbls is Nothing all relation labels are included (in default
--   order). If the row indices argument is nothing, all rows are included.
table :: Relvar -> Maybe [String] -> Maybe [(String, ColOrder)] -> Maybe [Int] -> Table

-- | Given a relation and some of its labels [ai0, ai1, ... ain], returns
--   the relation's attributes reordered with lftlbls on the left and then
--   the remaining labels from lbls.
keepLeft :: Relvar -> [String] -> [String]

-- | Given a relation and some of its labels [ai0, ai1, ... ain], returns
--   the relation's attributes reordered with lftlbls on the left and then
--   the remaining labels from lbls.
keepRight :: Relvar -> [String] -> [String]

-- | Mapping from Elem to their corresponding typeRep. Only relevant for
--   basic types and relations.
typeRep :: Elem -> TypeRep

-- | TypeRep for Bool.
tyB :: TypeRep

-- | TypeRep for Char.
tyC :: TypeRep

-- | TypeRep for String.
tyS :: TypeRep

-- | TypeRep for Text.
tyT :: TypeRep

-- | TypeRep for Int.
tyI :: TypeRep

-- | TypeRep for Integer.
tyJ :: TypeRep

-- | TypeRep for Double
tyD :: TypeRep

-- | TypeRep for Day.
tyDD :: TypeRep

-- | TypeRep for UTCTime.
tyDT :: TypeRep

-- | TypeRep for ByteString.
tyBS :: TypeRep

-- | TypeRep for Relvar.
tyR :: TypeRep

-- | TypeRep for [Elem].
tyA :: TypeRep

-- | TypeRep for (Elem, Elem).
tyT2 :: TypeRep

-- | TypeRep for (Elem, Elem, Elem).
tyT3 :: TypeRep

-- | TypeRep for Nil.
tyZ :: TypeRep
instance GHC.Classes.Ord Relvar.Table
instance GHC.Classes.Eq Relvar.Table
instance GHC.Show.Show Relvar.Table
instance GHC.Classes.Ord Relvar.Elem
instance GHC.Classes.Eq Relvar.Elem
instance GHC.Show.Show Relvar.Relvar
instance GHC.Read.Read Relvar.ColOrder
instance GHC.Classes.Ord Relvar.ColOrder
instance GHC.Show.Show Relvar.ColOrder
instance GHC.Classes.Eq Relvar.ColOrder
instance GHC.Show.Show Relvar.Elem
instance Relvar.Elementable GHC.Types.Bool
instance Relvar.Elementable GHC.Types.Char
instance Relvar.Elementable GHC.Base.String
instance Relvar.Elementable Data.Text.Internal.Text
instance Relvar.Elementable GHC.Types.Int
instance Relvar.Elementable GHC.Integer.Type.Integer
instance Relvar.Elementable GHC.Types.Double
instance Relvar.Elementable Data.Time.Calendar.Days.Day
instance Relvar.Elementable Data.Time.Clock.UTC.UTCTime
instance Relvar.Elementable Data.ByteString.Internal.ByteString
instance Relvar.Elementable [Relvar.Elem]
instance Relvar.Elementable (Relvar.Elem, Relvar.Elem)
instance Relvar.Elementable (Relvar.Elem, Relvar.Elem, Relvar.Elem)
instance Relvar.Elementable Relvar.Relvar
instance Relvar.Elementable (Data.Ord.Down Relvar.Elem)
instance GHC.Classes.Eq Relvar.Relvar
instance GHC.Classes.Ord Relvar.Relvar
instance Relvar.LSet.LabelOp Relvar.Relvar


-- | Implementation of relational algebra and other operators over
--   <a>Relvar</a>s as defined in C.J. Date, "<i>An Introduction to
--   Database Systems</i>" Eighth Edition, chapter 7 ('Relational Algebra')
--   .
module Algebra

-- | Summarize operators.
data OpElem
Sum :: OpElem

-- | Count elements.
Count :: OpElem

-- | Arithmetic Average.
Avg :: OpElem

-- | Return the maximum element.
Max :: OpElem

-- | Return the minimum element.
Min :: OpElem

-- | Standard deviation.
Sdev :: OpElem

-- | Variance.
Var :: OpElem

-- | Union operator. The two relations' attributes must be equal.
union :: Relvar -> Relvar -> Relvar

-- | Intersection operator The two relations' attributes must be equal (see
--   <a>match</a>).
intersection :: Relvar -> Relvar -> Relvar

-- | Difference operator. The two relations' attributes must be equal (see
--   <a>match</a>).
minus :: Relvar -> Relvar -> Relvar

-- | Product operator. The two relations' attributes must be disjoint.
times :: Relvar -> Relvar -> Relvar

-- | Filter a relation's rows given a ([Elem] -&gt; Bool) function and a
--   list of attribute names.
restrict :: Relvar -> ([Elem] -> Bool) -> [String] -> Relvar

-- | Projection on a given set of attributes. Only attributes with labels
--   in the provided list are included.
project :: Relvar -> [String] -> Relvar

-- | Projection on a given set of attributes. Attributes with labels
--   matching the list are excluded.
projectaway :: Relvar -> [String] -> Relvar

-- | Natural join operator. The two relations' attributes must not be
--   disjoint. The resulting
join :: Relvar -> Relvar -> Relvar

-- | Similar to the join operator projected over the attributes of the
--   first relation. Loosely speaking the results of semiJoin r1 r2 are the
--   rows of r1 which have a counterpart in r2.
--   
--   <pre>
--   r1 `semiJoin` r2 == project (r1 `join` r2) (labels r1)
--   </pre>
semiJoin :: Relvar -> Relvar -> Relvar

-- | Similar to the minus operator projected over the attributes of the
--   first relation. Loosely speaking the results of semiMinus r1 r2 are
--   the rows of r1 which do not have a counterpart in r2.
--   
--   <pre>
--   r1 `semiMinus` r2 == project (r1 `minus` r2) (labels r1)
--   </pre>
--   
--   <pre>
--   r1 `semiMinus` r2 == r1 `minus` (r1 `semiJoin` r2)
--   </pre>
semiMinus :: Relvar -> Relvar -> Relvar

-- | Add a derived column to an existing relation. Each element in the new
--   column is the result of a computation of some other columns.
extend :: Relvar -> ([Elem] -> Elem) -> [String] -> String -> Relvar

-- | <tt>summarize r per ops inlbls outlbls</tt> computes ops over inlbls
--   columns into outlbls column.
summarize :: Relvar -> Relvar -> [OpElem] -> [String] -> [String] -> Relvar

-- | <tt>group r grplbls reslbl</tt> returns a relation with all of r's
--   attributes, excluding grplbls columns, plus reslbl column. The
--   elements in reslbl column are of type <a>Relvar</a> and the result of
--   grouping of grplbls columns over the non-grplbls of r.
--   
--   <pre>
--   degree (group r grplbls reslbl) == degree r - (length grplbls) + 1
--   </pre>
group :: Relvar -> [String] -> String -> Relvar

-- | <a>group</a> inverse operator.
ungroup :: Relvar -> String -> Relvar
instance GHC.Show.Show Algebra.OpElem
instance GHC.Classes.Eq Algebra.OpElem


-- | Boilerplate code to translate <tt>a-&gt;b</tt> functions into
--   corresponding <tt>'Relvar.Elem'-&gt;'Relvar.Elem'</tt> functions (see
--   <tt>liftElem</tt>) and also into
--   <tt>[<a>Elem</a>]-&gt;<a>Elem</a></tt> functions for the function
--   <a>extend</a>.
module Algebra.Function

-- | Lifting functions into the "Elem domain" Use this class to translate f
--   :: a -&gt; b into the corresponding (Elem -&gt; Elem) function
class (Elementable a, Elementable b) => LiftElem a b where liftLeft' f x = case fromElem x of { Nothing -> Nothing Just x' -> Just (f x') } liftLeft f [] = error "Empty argument list" liftLeft f (x : xs) = (liftLeft' f) x liftEl' f x = case (liftLeft' f) x of { Nothing -> Nil Just z -> toElem z } liftEl f (x : xs) = (liftEl' f) x liftEl f [] = Nil
liftLeft' :: LiftElem a b => (a -> b) -> (Elem -> Maybe b)
liftLeft :: LiftElem a b => (a -> b) -> ([Elem] -> Maybe b)
liftEl' :: LiftElem a b => (a -> b) -> (Elem -> Elem)
liftEl :: LiftElem a b => (a -> b) -> ([Elem] -> Elem)

-- | Lifting functions into the "Elem domain" Use this class to translate f
--   :: a1 -&gt; a2 -&gt; b into the corresponding (Elem -&gt; Elem -&gt;
--   Elem) function
class (Elementable a1, Elementable a2, Elementable b) => LiftElem2 a1 a2 b where liftLeft2' f x y = case (fromElem x, fromElem y) of { (Just x', Just y') -> Just (f x' y') otherwise -> Nothing } liftLeft2 f [] = error "Empty argument list" liftLeft2 f (x : []) = error "Argument list: Need 2 or more elements" liftLeft2 f (x : y : xs) = (liftLeft2' f) x y liftEl2' f x y = case (liftLeft2' f) x y of { Nothing -> Nil Just z -> toElem z } liftEl2 f (x : y : xs) = (liftEl2' f) x y liftEl2 f _ = Nil
liftLeft2' :: LiftElem2 a1 a2 b => (a1 -> a2 -> b) -> (Elem -> Elem -> Maybe b)
liftLeft2 :: LiftElem2 a1 a2 b => (a1 -> a2 -> b) -> ([Elem] -> Maybe b)
liftEl2' :: LiftElem2 a1 a2 b => (a1 -> a2 -> b) -> (Elem -> Elem -> Elem)
liftEl2 :: LiftElem2 a1 a2 b => (a1 -> a2 -> b) -> ([Elem] -> Elem)

-- | Lifting functions into the "Elem domain" Use this class to translate f
--   :: a1 -&gt; a2 -&gt; a3 -&gt; b into the corresponding (Elem -&gt;
--   Elem -&gt; Elem -&gt; Elem) function
class (Elementable a1, Elementable a2, Elementable a3, Elementable b) => LiftElem3 a1 a2 a3 b where liftLeft3' f x1 x2 x3 = case (fromElem x1, fromElem x2, fromElem x3) of { (Just x1', Just x2', Just x3') -> Just (f x1' x2' x3') otherwise -> Nothing } liftLeft3 f [] = error "Empty argument list" liftLeft3 f (x1 : []) = error "Argument list: Need 3 or more elements" liftLeft3 f (x1 : x2 : []) = error "Argument list: Need 3 or more elements" liftLeft3 f (x1 : x2 : x3 : xs) = (liftLeft3' f) x1 x2 x3 liftEl3' f x1 x2 x3 = case (liftLeft3' f) x1 x2 x3 of { Nothing -> Nil Just z -> toElem z } liftEl3 f (x1 : x2 : x3 : xs) = (liftEl3' f) x1 x2 x3 liftEl3 f _ = Nil
liftLeft3' :: LiftElem3 a1 a2 a3 b => (a1 -> a2 -> a3 -> b) -> (Elem -> Elem -> Elem -> Maybe b)
liftLeft3 :: LiftElem3 a1 a2 a3 b => (a1 -> a2 -> a3 -> b) -> ([Elem] -> Maybe b)
liftEl3' :: LiftElem3 a1 a2 a3 b => (a1 -> a2 -> a3 -> b) -> (Elem -> Elem -> Elem -> Elem)
liftEl3 :: LiftElem3 a1 a2 a3 b => (a1 -> a2 -> a3 -> b) -> ([Elem] -> Elem)

-- | <a>Lifting</a> (a-&gt;Bool) functions to ([Elem]-&gt;Bool) functions.
--   This is a convenience function when using <a>restrict</a> function.
class LiftElem a Bool => BoolFun a where liftBoolFun f x = fromMaybe False $ liftLeft f x
liftBoolFun :: BoolFun a => (a -> Bool) -> ([Elem] -> Bool)

-- | <a>Lifting</a> (a1-&gt;a2-&gt;Bool) functions to ([Elem]-&gt;Bool)
--   functions. This is a convenience function when using <a>restrict</a>
--   function.
class LiftElem2 a1 a2 Bool => BoolFun2 a1 a2 where liftBoolFun2 f x = fromMaybe False $ liftLeft2 f x
liftBoolFun2 :: BoolFun2 a1 a2 => (a1 -> a2 -> Bool) -> ([Elem] -> Bool)

-- | <a>Lifting</a> (a1-&gt;a2-&gt;Bool) functions to ([Elem]-&gt;Bool)
--   functions. This is a convenience function when using <a>restrict</a>
--   function.
class LiftElem3 a1 a2 a3 Bool => BoolFun3 a1 a2 a3 where liftBoolFun3 f x = fromMaybe False $ liftLeft3 f x
liftBoolFun3 :: BoolFun3 a1 a2 a3 => (a1 -> a2 -> a3 -> Bool) -> ([Elem] -> Bool)
instance Algebra.Function.BoolFun GHC.Types.Bool
instance Algebra.Function.BoolFun GHC.Types.Char
instance Algebra.Function.BoolFun GHC.Base.String
instance Algebra.Function.BoolFun Data.Text.Internal.Text
instance Algebra.Function.BoolFun GHC.Types.Int
instance Algebra.Function.BoolFun GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun GHC.Types.Double
instance Algebra.Function.BoolFun Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun Relvar.Relvar
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem Relvar.Relvar a
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Types.Bool Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Types.Bool GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Types.Bool Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Types.Bool Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Types.Bool Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Types.Bool Relvar.Relvar
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Types.Char Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Types.Char GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Types.Char Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Types.Char Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Types.Char Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Types.Char Relvar.Relvar
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Base.String Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Base.String GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Base.String Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Base.String Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Base.String Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Base.String Relvar.Relvar
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Types.Bool
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Types.Char
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Base.String
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Types.Int
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text GHC.Types.Double
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 Data.Text.Internal.Text Relvar.Relvar
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Types.Int Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Types.Int GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Types.Int Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Types.Int Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Types.Int Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Types.Int Relvar.Relvar
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Integer.Type.Integer Relvar.Relvar
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Types.Bool
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Types.Char
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Base.String
instance Algebra.Function.BoolFun2 GHC.Types.Double Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Types.Int
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 GHC.Types.Double GHC.Types.Double
instance Algebra.Function.BoolFun2 GHC.Types.Double Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 GHC.Types.Double Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 GHC.Types.Double Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 GHC.Types.Double Relvar.Relvar
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Types.Bool
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Types.Char
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Base.String
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Types.Int
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day GHC.Types.Double
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 Data.Time.Calendar.Days.Day Relvar.Relvar
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Types.Bool
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Types.Char
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Base.String
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Types.Int
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime GHC.Types.Double
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 Data.Time.Clock.UTC.UTCTime Relvar.Relvar
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Types.Bool
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Types.Char
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Base.String
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Types.Int
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString GHC.Types.Double
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 Data.ByteString.Internal.ByteString Relvar.Relvar
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Types.Bool
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Types.Char
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Base.String
instance Algebra.Function.BoolFun2 Relvar.Relvar Data.Text.Internal.Text
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Types.Int
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Integer.Type.Integer
instance Algebra.Function.BoolFun2 Relvar.Relvar GHC.Types.Double
instance Algebra.Function.BoolFun2 Relvar.Relvar Data.Time.Calendar.Days.Day
instance Algebra.Function.BoolFun2 Relvar.Relvar Data.Time.Clock.UTC.UTCTime
instance Algebra.Function.BoolFun2 Relvar.Relvar Data.ByteString.Internal.ByteString
instance Algebra.Function.BoolFun2 Relvar.Relvar Relvar.Relvar
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Bool Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Char Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Base.String Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Text.Internal.Text Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Int Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Integer.Type.Integer Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 GHC.Types.Double Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Calendar.Days.Day Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.Time.Clock.UTC.UTCTime Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Data.ByteString.Internal.ByteString Relvar.Relvar a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Types.Bool a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Types.Char a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Base.String a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar Data.Text.Internal.Text a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Types.Int a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Integer.Type.Integer a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar GHC.Types.Double a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar Data.Time.Calendar.Days.Day a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar Data.Time.Clock.UTC.UTCTime a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar Data.ByteString.Internal.ByteString a
instance Relvar.Elementable a => Algebra.Function.LiftElem2 Relvar.Relvar Relvar.Relvar a


-- | Set of convenience functions to render relations and output them to
--   stdout.
--   
--   Credit: This module is based on a modified version of
--   Text.PrettyPrint.Boxes in the boxes package. Original version by Brent
--   Yorgey and David Feuer <a>here</a> and <a>here</a>. Modified version
--   by rustydc <a>here</a>.
--   
--   The original boxes package cannot be used as is, as it does not handle
--   Text type (and therefore does not allow Unicode characters output).
module Relvar.Pretty

-- | Box parameters.
data Params
Params :: Int -> Bool -> Bool -> Bool -> Bool -> Alignment -> Params
[col_width_min] :: Params -> Int
[border_top] :: Params -> Bool
[border_bot] :: Params -> Bool
[border_lft] :: Params -> Bool
[border_rgt] :: Params -> Bool
[col_align] :: Params -> Alignment

-- | Data type for specifying the alignment of boxes.
data Alignment

-- | Align at the top/left.
AlignFirst :: Alignment

-- | Centered, biased to the top/left.
AlignCenter1 :: Alignment

-- | Centered, biased to the bottom/right.
AlignCenter2 :: Alignment

-- | Align at the bottom/right.
AlignLast :: Alignment

-- | Render a Relvar as a Text, suitable for writing to the screen or a
--   file.
render' :: Tabular a => a -> Params -> [Int] -> Text

-- | Render a Relvar as a Text. Identical to <a>render'</a> but
--   <a>defParams</a> is used and all rows are shown.
render :: Tabular a => a -> Text

-- | Output a relation to the screen, given parameters and the number of
--   rows to output.
view' :: Tabular a => a -> Params -> [Int] -> IO ()

-- | Output a relation to the screen. Identical to <a>view'</a> but with
--   defParams.
view :: Tabular a => a -> [Int] -> IO ()

-- | Output a relation to the screen. Identical to <a>viewAll'</a> but with
--   defParams.
viewAll :: Tabular a => a -> IO ()

-- | Output a relation to the screen. Identical to <a>view'</a> but showing
--   all rows.
viewAll' :: Tabular a => a -> Params -> IO ()

-- | Default parameters.
--   
--   <pre>
--   col_width_min = 10, border_top = False, border_bot = False, border_lft = False, border_rgt = False, col_align = left
--   </pre>
defParams :: Params
instance GHC.Show.Show Relvar.Pretty.Params
instance GHC.Read.Read Relvar.Pretty.Params
instance GHC.Classes.Eq Relvar.Pretty.Params
instance Relvar.Pretty.Tabular Relvar.Relvar
instance Relvar.Pretty.Tabular Relvar.Table


-- | Import and convert csv files of basic types elements (only) into
--   <a>Elem</a>s and produce the corresponding relation. Note that
--   duplicate rows will be merged into one.
module Relvar.CSV

-- | Settings for a CSV file. This library is intended to be flexible and
--   offer a way to process the majority of text data files out there.
data CSVSettings :: *
CSVSettings :: UnpkChar -> SrictNotUnpacked(Maybe Char) -> CSVSettings

-- | Separator character to be used in between fields
[csvSep] :: CSVSettings -> UnpkChar

-- | Quote character that may sometimes be present around fields. If
--   <a>Nothing</a> is given, the library will never expect quotation even
--   if it is present.
[csvQuoteChar] :: CSVSettings -> SrictNotUnpacked(Maybe Char)

-- | Given an appropriate TypeRep mapping, convert a CSV string to Elem.
fromCSV :: Ord a => (Map a TypeRep) -> a -> String -> Elem

-- | <tt>toRelation filepath delimiter labels types</tt> to corresponding
--   IO (<a>Relvar</a>).
toRelation :: String -> Char -> [String] -> [TypeRep] -> IO (Relvar)
